==============================================================================
ESTRATÉGIA DE PRODUTO: SAAS SELF-HOSTED (CÓDIGO FECHADO)
Data: 21/12/2025
Objetivo: Transformar o projeto atual em um produto instalável, seguro e monetizável via doações.
==============================================================================

1. CONCEITO GERAL
------------------------------------------------------------------------------
O modelo de negócio é "Self-Hosted Proprietary Software". 
- O usuário baixa e instala o software no próprio servidor (VPS ou PC Local).
- O software é Gratuito para uso ilimitado.
- Monetização: "Nagware" (Sponsorware). O sistema exibe um pop-up/banner pedindo doação. 
- O doador recebe uma chave (License Key) que remove esse aviso visual.
- O código fonte NÃO é distribuído. O usuário recebe apenas o executável (binário).

2. ARQUITETURA TÉCNICA
------------------------------------------------------------------------------
A. Backend (FastAPI - Python)
   - O código não será distribuído como arquivos .py.
   - Ferramenta: Nuitka (Compilador de Python para C++).
   - Resultado: Transforma todo o backend em um executável binário (ELF/Binary).
   - Segurança: Impede leitura do código fonte e engenharia reversa simples.
   - Performance: O código compilado tende a rodar mais rápido.

B. Frontend (React/Nuxt)
   - Build padrão de produção (`npm run build`).
   - O código é minificado e ofuscado (padrão da web), dificultando edições manuais para remover os créditos/pop-ups.

C. Banco de Dados
   - O software usa um container PostgreSQL.
   - O esquema de dados (tabelas) é criado automaticamente pelo backend ao iniciar (Migrations embutidas).
   - O usuário tem controle total sobre os dados dele (estão na máquina dele).

3. GERENCIAMENTO DE SEGURANÇA E CHAVES (API KEYS)
------------------------------------------------------------------------------
Como o software roda na máquina do cliente, ele deve fornecer os recursos externos.

A. APIs de IA (Gemini, OpenAI, etc)
   - O código NUNCA terá suas chaves hardcoded.
   - O sistema lerá Variáveis de Ambiente do sistema operacional.
   - Exemplo no código: `api_key = os.getenv("GEMINI_KEY")`.
   - Se a chave não existir, o sistema avisa o usuário no Frontend.

B. Segurança
   - O seu binário apenas processa os dados.
   - A chave do usuário nunca sai do servidor dele (não é enviada para você).

4. ESTRATÉGIA DE LICENCIAMENTO (REMOÇÃO DO POP-UP)
------------------------------------------------------------------------------
Sistema Offline de Validação (Não requer servidor central 24/7).

A. A Lógica
   1. O Backend possui uma "SECRET_KEY" mestra embutida dentro do binário compilado.
   2. O Frontend consulta o Backend: "Devo mostrar o pop-up?".
   3. O Backend verifica se existe uma licença válida no ambiente.

B. Fluxo de Doação
   1. Usuário faz a doação (Pix/Paypal).
   2. Você gera um Token JWT (License Key) assinado com sua SECRET_KEY mestra.
      - Payload do Token: `{"email": "cliente@email.com", "type": "sponsor"}`.
   3. Usuário recebe a chave e coloca no arquivo `.env`.

C. Validação no Código
   - O Backend tenta decodificar o token usando a SECRET_KEY interna.
   - Se a assinatura bater (matemática correta) -> Retorna `show_ads: false`.
   - Se a assinatura falhar ou não existir -> Retorna `show_ads: true`.

5. ESTRATÉGIA DE DISTRIBUIÇÃO (DOCKER)
------------------------------------------------------------------------------
O cliente não baixa código do GitHub. Ele baixa uma Imagem Docker pronta.

A. Dockerfile "Anti-Cópia" (Multi-stage Build)
   - Estágio 1 (Builder): Instala Python, Nuitka, dependências. Compila tudo.
   - Estágio 2 (Final): Copia APENAS o arquivo binário gerado. 
   - Resultado: Uma imagem leve, sem código fonte, apenas o executável.

B. O que o Cliente Recebe
   Apenas um arquivo `docker-compose.yml` e um `.env.example`.

   Exemplo do docker-compose do cliente:
   -------------------------------------
   services:
     app:
       image: marcos/projeto-saas:latest  <-- Sua imagem fechada no DockerHub
       environment:
         - GEMINI_API_KEY=chave_do_cliente_aqui
         - LICENSE_KEY=chave_de_doador_(opcional)
       ports:
         - "80:80"
   -------------------------------------

6. INFRAESTRUTURA RECOMENDADA (PARA VOCÊ)
------------------------------------------------------------------------------
Para hospedar sua versão de demonstração ou gerenciar o build:
- Servidor: VPS (Hetzner, DigitalOcean ou AWS EC2).
- Gerenciador: Coolify (para CI/CD automático e gestão de containers).
- Proxy: Traefik ou Nginx (Gerenciamento de domínios e HTTPS automático).

7. RESUMO DO ROADMAP DE IMPLEMENTAÇÃO
------------------------------------------------------------------------------
1. [Código] Refatorar hardcoded keys para usar `os.getenv`.
2. [Código] Criar lógica de validação de JWT (Licença) no Backend.
3. [Frontend] Criar componente Modal "Sponsor" que obedece à API do Backend.
4. [Build] Criar Dockerfile com Nuitka para compilar o Backend.
5. [Distribuição] Subir imagem para Docker Hub e criar documentação de instalação.